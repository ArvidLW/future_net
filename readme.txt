



2.2、从2.1可以看到模型的转化已经完毕,可以使用LKH算法求出must点组成的atsp问题的解.
但是这个转化有一个致命问题,就是non-must点可能在atsp的解中出现多次,这是由于求最短路的松弛操作造成的,可能很多必须点间最短路经过了同一个non-must点,我们的理解就是:压缩规模就等于偷懒了.
解决方案有二:
①找出所有使用次数超过一遍的non-must点,有选择性地进行"升级操作"(升级non-must点为must点)
②找出所有使用次数超过一遍的non-must点,将所有点进行"升级操作",配合使用"double所有non-must点的模型"
方案①是初赛我们使用的方案,需要找到一个"选择规则",通过分析,升级哪些"重复non-must点"没有什么规律.但也能找到一个比较通用的规律(不能适用于所有case),也就是初赛中我们使用的规则为:在atsp的解中,升级"must点"间最靠近这两个端点的"重复使用的non-must点".
方案②只是方案①的一个特例,复赛和决赛我们使用的是此方案.为什么要加入所有的呢?因为经验如此,但有一些特例是使用此方案求不出解.出于对效率的考虑,我们选择这个方案,毕竟大多数情况不会出现特例.为了应付特例的,也就是使用此方案求不出解的时候,恢复升级操作之前的状态,使用"double所有non-must点的模型"求解.

2.3、在使用升级操作得到新的解后,继续检查有没有"重复使用的non-must点",如果没有则单条路得解已经求出,如果还有则不断使用2.1和2.2,直到没有"重复使用的non-must点"为止.经验来看,通常升级操作平均只需要0-2次,也就是说atsp只需要求解很少的次数.相对于一次性求解大规模的atsp,不如求几次经过压缩的小规模atsp问题,因为求解atsp算法复杂度都很高(LKH是n^2.2),所以降压是个好的选择.



